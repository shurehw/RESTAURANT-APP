-- ================================================================
-- MIGRATION 203: Automation Infrastructure
-- ================================================================
-- Purpose: Add tables and columns to support automated scheduling
-- Created: 2026-02-05
-- ================================================================

-- ================================================================
-- 1. AUTOMATION JOB TRACKING
-- ================================================================

CREATE TABLE IF NOT EXISTS automation_job_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_name TEXT NOT NULL,
  venue_id UUID REFERENCES venues(id) ON DELETE CASCADE,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  status TEXT NOT NULL DEFAULT 'running'
    CHECK (status IN ('running', 'success', 'failed')),
  output JSONB,
  error TEXT,
  duration_seconds NUMERIC(8,2),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for efficient queries
CREATE INDEX IF NOT EXISTS idx_automation_job_runs_job_name
  ON automation_job_runs(job_name);
CREATE INDEX IF NOT EXISTS idx_automation_job_runs_venue_id
  ON automation_job_runs(venue_id);
CREATE INDEX IF NOT EXISTS idx_automation_job_runs_started_at
  ON automation_job_runs(started_at DESC);
CREATE INDEX IF NOT EXISTS idx_automation_job_runs_status
  ON automation_job_runs(status);

COMMENT ON TABLE automation_job_runs IS 'Tracks all automated job executions (forecasts, schedules, CPLH updates)';
COMMENT ON COLUMN automation_job_runs.job_name IS 'Name of the job (e.g., forecast-generate, schedule-generate)';
COMMENT ON COLUMN automation_job_runs.output IS 'JSON output from the job execution';
COMMENT ON COLUMN automation_job_runs.error IS 'Error message if job failed';
COMMENT ON COLUMN automation_job_runs.duration_seconds IS 'How long the job took to run';

-- ================================================================
-- 2. SCHEDULE APPROVAL WORKFLOW
-- ================================================================

CREATE TABLE IF NOT EXISTS schedule_approvals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  schedule_id UUID NOT NULL REFERENCES weekly_schedules(id) ON DELETE CASCADE,
  approved_by UUID NOT NULL REFERENCES auth.users(id),
  approved_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  approval_notes TEXT,
  changes_made JSONB,
  previous_status TEXT,
  new_status TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_schedule_approvals_schedule_id
  ON schedule_approvals(schedule_id);
CREATE INDEX IF NOT EXISTS idx_schedule_approvals_approved_by
  ON schedule_approvals(approved_by);
CREATE INDEX IF NOT EXISTS idx_schedule_approvals_approved_at
  ON schedule_approvals(approved_at DESC);

COMMENT ON TABLE schedule_approvals IS 'Tracks schedule approval history';
COMMENT ON COLUMN schedule_approvals.changes_made IS 'JSON array of changes made to the schedule before approval';

-- ================================================================
-- 3. ENHANCE EXISTING TABLES
-- ================================================================

-- Add automation columns to weekly_schedules
ALTER TABLE weekly_schedules
  ADD COLUMN IF NOT EXISTS auto_generated BOOLEAN DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS requires_approval BOOLEAN DEFAULT TRUE,
  ADD COLUMN IF NOT EXISTS approved_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS approved_by UUID REFERENCES auth.users(id);

COMMENT ON COLUMN weekly_schedules.auto_generated IS 'TRUE if schedule was generated by automation (vs manual)';
COMMENT ON COLUMN weekly_schedules.requires_approval IS 'TRUE if schedule needs manager approval before publishing';
COMMENT ON COLUMN weekly_schedules.approved_at IS 'Timestamp when schedule was approved';
COMMENT ON COLUMN weekly_schedules.approved_by IS 'User who approved the schedule';

-- Add seasonal event tracking to demand_forecasts
ALTER TABLE demand_forecasts
  ADD COLUMN IF NOT EXISTS seasonal_uplift_applied NUMERIC(5,2),
  ADD COLUMN IF NOT EXISTS seasonal_event_id UUID,
  ADD COLUMN IF NOT EXISTS forecast_source TEXT DEFAULT 'ml_model'
    CHECK (forecast_source IN ('ml_model', 'manual', 'adjusted'));

COMMENT ON COLUMN demand_forecasts.seasonal_uplift_applied IS 'Percentage uplift applied (e.g., 25.0 for 25%)';
COMMENT ON COLUMN demand_forecasts.seasonal_event_id IS 'FK to seasonal_events (will be created in migration 204)';
COMMENT ON COLUMN demand_forecasts.forecast_source IS 'How this forecast was created';

-- ================================================================
-- 4. ROW LEVEL SECURITY (RLS)
-- ================================================================

-- Enable RLS on new tables
ALTER TABLE automation_job_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE schedule_approvals ENABLE ROW LEVEL SECURITY;

-- RLS Policy: automation_job_runs
-- Users can view jobs for their venues
CREATE POLICY automation_job_runs_select ON automation_job_runs
  FOR SELECT
  USING (
    venue_id IN (
      SELECT v.id FROM venues v
      JOIN organization_users ou ON ou.organization_id = v.organization_id
      WHERE ou.user_id = auth.uid() AND ou.is_active = TRUE
    )
    OR venue_id IS NULL -- Allow viewing global jobs
  );

-- Only service role can insert job runs (automated jobs)
CREATE POLICY automation_job_runs_insert ON automation_job_runs
  FOR INSERT
  WITH CHECK (true); -- Will be restricted via API with service role key

-- RLS Policy: schedule_approvals
-- Users can view approvals for their schedules
CREATE POLICY schedule_approvals_select ON schedule_approvals
  FOR SELECT
  USING (
    schedule_approvals.schedule_id IN (
      SELECT ws.id FROM weekly_schedules ws
      JOIN venues v ON v.id = ws.venue_id
      JOIN organization_users ou ON ou.organization_id = v.organization_id
      WHERE ou.user_id = auth.uid() AND ou.is_active = TRUE
    )
  );

-- Managers can create approvals
CREATE POLICY schedule_approvals_insert ON schedule_approvals
  FOR INSERT
  WITH CHECK (
    schedule_approvals.approved_by = auth.uid()
    AND EXISTS (
      SELECT 1 FROM organization_users ou
      JOIN venues v ON v.organization_id = ou.organization_id
      JOIN weekly_schedules ws ON ws.venue_id = v.id
      WHERE ws.id = schedule_approvals.schedule_id
        AND ou.user_id = auth.uid()
        AND ou.is_active = TRUE
        AND ou.role IN ('owner', 'admin', 'manager')
    )
  );

-- ================================================================
-- 5. HELPER FUNCTIONS
-- ================================================================

-- Function to get recent job runs
CREATE OR REPLACE FUNCTION get_recent_job_runs(
  p_venue_id UUID DEFAULT NULL,
  p_limit INTEGER DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  job_name TEXT,
  venue_id UUID,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  status TEXT,
  duration_seconds NUMERIC,
  error TEXT,
  output JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    ajr.id,
    ajr.job_name,
    ajr.venue_id,
    ajr.started_at,
    ajr.completed_at,
    ajr.status,
    ajr.duration_seconds,
    ajr.error,
    ajr.output
  FROM automation_job_runs ajr
  WHERE (p_venue_id IS NULL OR ajr.venue_id = p_venue_id)
  ORDER BY ajr.started_at DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION get_recent_job_runs IS 'Retrieve recent automation job runs for monitoring';

-- Function to get job success rate
CREATE OR REPLACE FUNCTION get_job_success_rate(
  p_job_name TEXT,
  p_days_back INTEGER DEFAULT 7
)
RETURNS TABLE (
  job_name TEXT,
  total_runs BIGINT,
  successful_runs BIGINT,
  failed_runs BIGINT,
  success_rate NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    p_job_name AS job_name,
    COUNT(*) AS total_runs,
    COUNT(*) FILTER (WHERE status = 'success') AS successful_runs,
    COUNT(*) FILTER (WHERE status = 'failed') AS failed_runs,
    ROUND(
      (COUNT(*) FILTER (WHERE status = 'success')::NUMERIC / NULLIF(COUNT(*), 0)) * 100,
      2
    ) AS success_rate
  FROM automation_job_runs
  WHERE job_name = p_job_name
    AND started_at >= NOW() - (p_days_back || ' days')::INTERVAL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION get_job_success_rate IS 'Calculate success rate for a specific job over the last N days';

-- ================================================================
-- 6. GRANT PERMISSIONS
-- ================================================================

-- Grant access to authenticated users (via RLS policies)
GRANT SELECT ON automation_job_runs TO authenticated;
GRANT SELECT ON schedule_approvals TO authenticated;
GRANT INSERT ON schedule_approvals TO authenticated;

-- Grant access to service role (for automated jobs)
GRANT ALL ON automation_job_runs TO service_role;
GRANT ALL ON schedule_approvals TO service_role;

-- ================================================================
-- END OF MIGRATION 203
-- ================================================================
